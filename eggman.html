<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title>Eggman</title>
</head>
<body>
<script id="vs" type="x-shader/x-vertex">
	attribute vec3 pos;
	void main() {
		gl_Position = vec4(pos, 1.0);
	}
</script>
<script id="fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif

uniform float time;
//uniform vec2 mouse;
uniform vec2 resolution;
uniform sampler2D sampler;
uniform sampler2D normals;

float PI = 3.14159265358979323846264;
vec3 lightPosition = vec3(100.0, 200.0, 500.0);
vec3 eye = vec3(0.0, 200.0, 500.0);

vec2 center = vec2(350.0, 200.0);
vec2 f1 = center + vec2(0.0, -100.0);
vec2 f2 = center + vec2(0.0, 100.0);
float ellipseConstant = 245.0;

float square(float value) {
	return value * value;
}

vec3 muster(vec2 pos) {
	return vec3(sin(pos.x * 200.0) * sin(pos.y / 10.0), 1.0, 1.0);
}

float saturate(float value) {
	return clamp(value, 0.0, 1.0);	
}

float calcRadius(vec2 pos, vec2 f1, vec2 f2, float ellipseConstant) {
	float x = distance(pos.y, f1.y);
	float y = distance(pos.y, f2.y);
	float c = ellipseConstant;
	
	float bruch = (square(c) + square(x) - square(y)) / (2.0 * c);
	
	return sqrt(square(bruch) - square(x));
}

vec3 angleBisector(vec3 a, vec3 b) {
	return normalize(a / length(a) + b / length(b));
}

void main() {
	vec2 position = gl_FragCoord.xy;

	gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	
	lightPosition.x = sin(time) * 1000.0;
	lightPosition.y = sin(time * 0.5) * 2000.0;
	
	if (distance(position, f1) + distance(position, f2) < ellipseConstant) {
		float radius = calcRadius(position, f1, f2, ellipseConstant);
		float winkel = asin(abs(position.x - center.x) / radius);
		
		float z = radius * cos(winkel);
		//z = sqrt(square(radius) - square(position.x - center.x));
		//z *= 0.01;
		vec3 world = vec3(position, z);
		//vec3 normal = normalize(world - vec3(center, 0.0));

		vec3 normal = angleBisector(world - vec3(f1, 0.0), world - vec3(f2, 0.0));

		vec3 tangent = angleBisector(world - vec3(f2, 0.0), vec3(f1, 0.0) - world);

		if (position.x < center.x) winkel = PI / 2.0 - winkel;
		else winkel += PI / 2.0;
		winkel /= PI * 2.0;

		vec2 texcoord = vec2(winkel - time / 50.0, (position.y - center.y + ellipseConstant / 2.0) / ellipseConstant);

		vec3 tangentnormal = texture2D(normals, texcoord).rgb * 2.0 - 1.0;
		normal.x = dot(tangentnormal, cross(tangent, normal));
		normal.y = dot(tangentnormal, tangent);
		normal.z = dot(tangentnormal, normal);
		normal = normalize(normal);

		vec3 lightDirection = normalize(world - lightPosition);
		//lightDirection = vec3(0.1, 0.2, -0.7);
		float diffuse = saturate(dot(normal, -lightDirection));
		vec3 h = normalize(normalize(eye - world) - lightDirection);
		float specular = pow(saturate(dot(h, normal)), 15.0);
		float light = 0.2 + diffuse * 0.5;
		
		//winkel *= 20.0;
		//gl_FragColor = vec4(muster(vec2(winkel - time / 100.0, position.y)) * light + specular, 1.0);
		//gl_FragColor = vec4(diffuse, diffuse, diffuse, 1.0);
		//gl_FragColor = vec4(normal, 1.0);
		gl_FragColor = vec4(texture2D(sampler, texcoord).xyz * light + specular, 1.0);
	}
}
</script>
<script type="text/javascript">

function getSource(id) {
	var shaderScript = document.getElementById(id);
	var str = "";
	var k = shaderScript.firstChild;
	while (k) {
		if (k.nodeType == 3) str += k.textContent;
		k = k.nextSibling;
	}
	return str;
}

function shaderProgram(gl, vs, fs) {
	var prog = gl.createProgram();
	var addshader = function(type, source) {
		var s = gl.createShader((type == 'vertex') ?
			gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
		gl.shaderSource(s, source);
		gl.compileShader(s);
		if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
			throw "Could not compile "+type+
				" shader:\n\n"+gl.getShaderInfoLog(s);
		}
		gl.attachShader(prog, s);
	};
	addshader('vertex', getSource(vs));
	addshader('fragment', getSource(fs));
	gl.linkProgram(prog);
	if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
		throw "Could not link the shader program!";
	}
	return prog;
}

function attributeSetFloats(gl, prog, attr_name, rsize, arr) {
	gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr),
		gl.STATIC_DRAW);
	var attr = gl.getAttribLocation(prog, attr_name);
	gl.enableVertexAttribArray(attr);
	gl.vertexAttribPointer(attr, rsize, gl.FLOAT, false, 0, 0);
}

var thetime = 0.0;

var texture;
var normals;

function draw() {
	try {
		var gl = document.getElementById("webgl")
			.getContext("experimental-webgl");
		if (!gl) { throw "x"; }
	} catch (err) {
		throw "Your web browser does not support WebGL!";
	}
	gl.clearColor(0.0, 0.0, 0.0, 1.0);
	gl.clear(gl.COLOR_BUFFER_BIT);

	var prog = shaderProgram(gl, "vs", "fs");
	gl.useProgram(prog);

	gl.uniform1f(gl.getUniformLocation(prog, "time"), thetime);
	gl.uniform2f(gl.getUniformLocation(prog, "resolution"), 1640.0, 480.0);
	attributeSetFloats(gl, prog, "pos", 3, [
		-1, -1, 0,
		-1, 1, 0,
		1, -1, 0,
		1, 1, 0
	]);
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.uniform1i(gl.getUniformLocation(prog, "sampler"), 0);

	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, normals);
	gl.uniform1i(gl.getUniformLocation(prog, "normals"), 1);

	gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

	thetime += 1.0 / 60.0;

	setTimeout(draw, 1000.0 / 60.0);
}

function handleLoadedTexture(texture) {
	try {
		var gl = document.getElementById("webgl").getContext("experimental-webgl");
		if (!gl) { throw "x"; }
	} catch (err) {
		throw "Your web browser does not support WebGL!";
	}
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
	gl.generateMipmap(gl.TEXTURE_2D);
	gl.bindTexture(gl.TEXTURE_2D, null);
}

function initTexture() {
	try {
		var gl = document.getElementById("webgl").getContext("experimental-webgl");
		if (!gl) { throw "x"; }
	} catch (err) {
		throw "Your web browser does not support WebGL!";
	}
	texture = gl.createTexture();
	texture.image = new Image();
	texture.image.onload = function() {
		handleLoadedTexture(texture);
	}
	texture.image.src = "img_fur2.png";
	
	normals = gl.createTexture();
	normals.image = new Image();
	normals.image.onload = function() {
		handleLoadedTexture(normals);
	}
	normals.image.src = "img_fur2n.png";
}

function init() {
	try {
		initTexture();
		draw();
	} catch (e) {
		alert("Error: "+e);
	}
}
setTimeout(init, 100);

</script>
<canvas id="webgl" width="640" height="480"></canvas>
</body>
</html>