<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title>Eggman</title>
</head>
<body>
<script id="vs" type="x-shader/x-vertex">
	attribute vec3 pos;
	
	void main() {
		gl_Position = vec4(pos, 1.0);
	}
</script>

<script id="vs2" type="x-shader/x-vertex">
	attribute vec3 pos;
	attribute vec2 tex;
	varying vec4 position;
	varying vec2 texcoord;

	void main() {
		texcoord = tex;
		gl_Position = position = vec4(pos, 1.0);
	}
</script>

<script id="fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif

uniform float time;
//uniform vec2 mouse;
uniform vec2 resolution;
uniform sampler2D sampler;
uniform sampler2D normals;
uniform sampler2D facetex;

float PI = 3.14159265358979323846264;
vec3 lightPosition = vec3(100.0, 200.0, 500.0);
vec3 eye = vec3(0.0, 200.0, 500.0);

vec2 center = vec2(350.0, 200.0);
vec2 f1 = center + vec2(0.0, -100.0);
vec2 f2 = center + vec2(0.0, 100.0);
float ellipseConstant = 245.0;

float square(float value) {
	return value * value;
}

vec3 muster(vec2 pos) {
	return vec3(sin(pos.x * 200.0) * sin(pos.y / 10.0), 1.0, 1.0);
}

float saturate(float value) {
	return clamp(value, 0.0, 1.0);	
}

float calcRadius(vec2 pos, vec2 f1, vec2 f2, float ellipseConstant) {
	float x = distance(pos.y, f1.y);
	float y = distance(pos.y, f2.y);
	float c = ellipseConstant;
	
	float bruch = (square(c) + square(x) - square(y)) / (2.0 * c);
	
	return sqrt(square(bruch) - square(x));
}

vec3 angleBisector(vec3 a, vec3 b) {
	return normalize(a / length(a) + b / length(b));
}

void main() {
	vec2 position = gl_FragCoord.xy;

	gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	
	lightPosition.x = sin(time) * 1000.0;
	lightPosition.y = sin(time * 0.5) * 2000.0;
	
	if (distance(position, f1) + distance(position, f2) < ellipseConstant) {
		float radius = calcRadius(position, f1, f2, ellipseConstant);
		float winkel = asin(abs(position.x - center.x) / radius);
		
		float z = radius * cos(winkel);
		//z = sqrt(square(radius) - square(position.x - center.x));
		//z *= 0.01;
		vec3 world = vec3(position, z);
		//vec3 normal = normalize(world - vec3(center, 0.0));

		vec3 normal = angleBisector(world - vec3(f1, 0.0), world - vec3(f2, 0.0));

		vec3 tangent = angleBisector(world - vec3(f2, 0.0), vec3(f1, 0.0) - world);

		if (position.x < center.x) winkel = PI / 2.0 - winkel;
		else winkel += PI / 2.0;
		winkel /= PI * 2.0;

		vec2 texcoord = vec2(winkel - time / 20.0, (position.y - center.y + ellipseConstant / 2.0) / ellipseConstant);

		vec3 tangentnormal = texture2D(normals, texcoord).rgb * 2.0 - 1.0;
		normal.x = dot(tangentnormal, cross(tangent, normal));
		normal.y = dot(tangentnormal, tangent);
		normal.z = dot(tangentnormal, normal);
		normal = normalize(normal);

		vec3 lightDirection = normalize(world - lightPosition);
		//lightDirection = vec3(0.1, 0.2, -0.7);
		float diffuse = saturate(dot(normal, -lightDirection));
		vec3 h = normalize(normalize(eye - world) - lightDirection);
		float specular = pow(saturate(dot(h, normal)), 15.0);
		float light = 0.2 + diffuse * 0.5;
		
		//winkel *= 20.0;
		//gl_FragColor = vec4(muster(vec2(winkel - time / 100.0, position.y)) * light + specular, 1.0);
		//gl_FragColor = vec4(diffuse, diffuse, diffuse, 1.0);
		//gl_FragColor = vec4(normal, 1.0);
		float alpha = texture2D(facetex, texcoord).a;
		vec3 tex = texture2D(facetex, texcoord).rgb * alpha + texture2D(sampler, texcoord).rgb * (1.0 - alpha);
		gl_FragColor = vec4(tex * light + specular * (1.0 - alpha), 1.0);
	}
	else discard;
}
</script>

<script id="fs2" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif

vec3 lightPosition = vec3(100.0, 200.0, 500.0);
vec3 eye = vec3(0.0, 200.0, 500.0);
uniform sampler2D sampler;
uniform sampler2D normals;
uniform float time;
varying vec4 position;
varying vec2 texcoord;

float saturate(float value) {
	return clamp(value, 0.0, 1.0);	
}

void main() {
	gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	lightPosition.x = sin(time) * 1000.0;
	lightPosition.y = sin(time * 0.5) * 2000.0;
	//vec2 position = gl_FragCoord.xy;
	//vec2 texcoord = (position.xy + 1.0) / 2.0;
	vec3 normal = texture2D(normals, texcoord).rgb * 2.0 - 1.0;
	
	vec3 world = vec3(gl_FragCoord.xy, 0);
	vec3 lightDirection = normalize(world - lightPosition);
	//lightDirection = vec3(0.1, 0.2, -0.7);
	float diffuse = saturate(dot(normal, -lightDirection));
	vec3 h = normalize(normalize(eye - world) - lightDirection);
	float specular = pow(saturate(dot(h, normal)), 15.0);
	float light = 0.2 + diffuse * 0.5;
	
	//winkel *= 20.0;
	//gl_FragColor = vec4(muster(vec2(winkel - time / 100.0, position.y)) * light + specular, 1.0);
	//gl_FragColor = vec4(diffuse, diffuse, diffuse, 1.0);
	//gl_FragColor = vec4(normal, 1.0);
	gl_FragColor = vec4(texture2D(sampler, texcoord).xyz * light + specular, texture2D(sampler, texcoord).a);
}
</script>

<script type="text/javascript">

function getSource(id) {
	var shaderScript = document.getElementById(id);
	var str = "";
	var k = shaderScript.firstChild;
	while (k) {
		if (k.nodeType == 3) str += k.textContent;
		k = k.nextSibling;
	}
	return str;
}

function shaderProgram(gl, vs, fs) {
	var prog = gl.createProgram();
	var addshader = function(type, source) {
		var s = gl.createShader((type == 'vertex') ?
			gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
		gl.shaderSource(s, source);
		gl.compileShader(s);
		if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
			throw "Could not compile "+type+
				" shader:\n\n"+gl.getShaderInfoLog(s);
		}
		gl.attachShader(prog, s);
	};
	addshader('vertex', getSource(vs));
	addshader('fragment', getSource(fs));
	gl.linkProgram(prog);
	if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
		throw "Could not link the shader program!";
	}
	return prog;
}

function attributeSetFloats(gl, prog, attr_name, rsize, arr) {
	gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr),
		gl.STATIC_DRAW);
	var attr = gl.getAttribLocation(prog, attr_name);
	gl.enableVertexAttribArray(attr);
	gl.vertexAttribPointer(attr, rsize, gl.FLOAT, false, 0, 0);
}

var thetime = 0.0;
var gl;
var texture;
var normals;
var texture2;
var normals2;
var facetex;
var handtex;
var handnormals;
var foottex;
var footnormals;
var shader1;
var shader2;
var count = 0;
var requestAnimationFrame;

function drawObject(tex, norm, x, y, w, h, mirror, z) {
	if (z < 0) {
		z = -z;
		z /= 6;
		z += 1;
		w /= z;
		h /= z;
	}
	else {
		z /= 6;
		z += 1;
		w *= z;
		h *= z;
	}
	gl.useProgram(shader2);

	gl.uniform1f(gl.getUniformLocation(shader2, "time"), thetime);
	gl.uniform2f(gl.getUniformLocation(shader2, "resolution"), 640.0, 480.0);
	//var x = 0.14;
	//var y = 0.1;
	//var w = 0.3;
	//var h = 0.3;
	attributeSetFloats(gl, shader2, "pos", 3, [
		x - w / 2.0, y - h / 2.0, 0,
		x - w / 2.0,  y + h / 2.0, 0,
		 x + w / 2.0, y - h / 2.0, 0,
		 x + w / 2.0,  y + h / 2.0, 0
	]);
	if (mirror) {
		attributeSetFloats(gl, shader2, "tex", 2, [
			1.0, 0.0,
			1.0, 1.0,
			0.0, 0.0,
			0.0, 1.0
		]);
	}
	else {
		attributeSetFloats(gl, shader2, "tex", 2, [
			0.0, 0.0,
			0.0, 1.0,
			1.0, 0.0,
			1.0, 1.0
		]);
	}
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, tex);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.uniform1i(gl.getUniformLocation(shader2, "sampler"), 0);

	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, norm);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.uniform1i(gl.getUniformLocation(shader2, "normals"), 1);

	gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

function drawBody() {
	gl.useProgram(shader1);

	gl.uniform1f(gl.getUniformLocation(shader1, "time"), thetime);
	gl.uniform2f(gl.getUniformLocation(shader1, "resolution"), 640.0, 480.0);
	attributeSetFloats(gl, shader1, "pos", 3, [
		-1, -1, 0,
		-1,  1, 0,
		 1, -1, 0,
		 1,  1, 0
	]);
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	gl.uniform1i(gl.getUniformLocation(shader1, "sampler"), 0);

	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, normals);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	gl.uniform1i(gl.getUniformLocation(shader1, "normals"), 1);

	gl.activeTexture(gl.TEXTURE2);
	gl.bindTexture(gl.TEXTURE_2D, facetex);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.uniform1i(gl.getUniformLocation(shader1, "facetex"), 2);

	gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

	drawObject(texture2, normals2, 0.26, 0.3, 0.3, 0.3);
}

function drawStuff() {
	gl.clearColor(0.0, 0.0, 0.0, 1.0);
	gl.clear(gl.COLOR_BUFFER_BIT);

	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	gl.enable(gl.BLEND);

	var angle = Math.PI + thetime * Math.PI * 2.0 / 20.0;
	angle = angle % (Math.PI * 2.0);
	var z = Math.cos(angle);
	if (z <= 0) drawObject(handtex, handnormals, Math.sin(angle) * 0.3 + 0.1, -0.4, 0.5, 0.5, (angle > Math.PI) ? true : false, z);

	angle = thetime * Math.PI * 2.0 / 20.0;
	angle = angle % (Math.PI * 2.0);
	z = Math.cos(angle);
	if (z <= 0) drawObject(handtex, handnormals, Math.sin(angle) * 0.3 + 0.1, -0.4, 0.5, 0.5, (angle > Math.PI) ? true : false, z);

	angle = Math.PI + thetime * Math.PI * 2.0 / 20.0;
	angle = angle % (Math.PI * 2.0);
	z = Math.cos(angle);
	if (z <= 0) drawObject(foottex, footnormals, Math.sin(angle) * 0.2 + 0.1, -0.75, 0.5, 0.5, (angle > Math.PI) ? true : false, z);

	angle = thetime * Math.PI * 2.0 / 20.0;
	angle = angle % (Math.PI * 2.0);
	z = Math.cos(angle);
	if (z <= 0) drawObject(foottex, footnormals, Math.sin(angle) * 0.2 + 0.1, -0.75, 0.5, 0.5, (angle > Math.PI) ? true : false, z);

	drawBody();

	angle = Math.PI + thetime * Math.PI * 2.0 / 20.0;
	angle = angle % (Math.PI * 2.0);
	z = Math.cos(angle);
	if (z > 0) drawObject(handtex, handnormals, Math.sin(angle) * 0.3 + 0.1, -0.4, 0.5, 0.5, (angle > Math.PI) ? true : false, z);

	angle = thetime * Math.PI * 2.0 / 20.0;
	angle = angle % (Math.PI * 2.0);
	z = Math.cos(angle);
	if (z > 0) drawObject(handtex, handnormals, Math.sin(angle) * 0.3 + 0.1, -0.4, 0.5, 0.5, (angle > Math.PI) ? true : false, z);

	angle = Math.PI + thetime * Math.PI * 2.0 / 20.0;
	angle = angle % (Math.PI * 2.0);
	z = Math.cos(angle);
	if (z > 0) drawObject(foottex, footnormals, Math.sin(angle) * 0.2 + 0.1, -0.75, 0.5, 0.5, (angle > Math.PI) ? true : false, z);

	angle = thetime * Math.PI * 2.0 / 20.0;
	angle = angle % (Math.PI * 2.0);
	z = Math.cos(angle);
	if (z > 0) drawObject(foottex, footnormals, Math.sin(angle) * 0.2 + 0.1, -0.75, 0.5, 0.5, (angle > Math.PI) ? true : false, z);

}

function draw() {
	if (count == 9) {
		drawStuff();
		thetime += 1.0 / 60.0;
	}
	//setTimeout(draw, 1000.0 / 60.0);
	requestAnimationFrame(draw);
}

function handleLoadedTexture(texture) {
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
	gl.generateMipmap(gl.TEXTURE_2D);
	gl.bindTexture(gl.TEXTURE_2D, null);
}

function initTexture() {
	texture = gl.createTexture();
	texture.image = new Image();
	texture.image.onload = function() {
		++count;
		handleLoadedTexture(texture);
	}
	texture.image.src = "img_fur2.png";
	
	normals = gl.createTexture();
	normals.image = new Image();
	normals.image.onload = function() {
		++count;
		handleLoadedTexture(normals);
	}
	normals.image.src = "img_fur2n.png";

	texture2 = gl.createTexture();
	texture2.image = new Image();
	texture2.image.onload = function() {
		++count;
		handleLoadedTexture(texture2);
	}
	texture2.image.src = "img_ear09_overlay.png";
	
	normals2 = gl.createTexture();
	normals2.image = new Image();
	normals2.image.onload = function() {
		++count;
		handleLoadedTexture(normals2);
	}
	normals2.image.src = "img_ear09n.png";

	facetex = gl.createTexture();
	facetex.image = new Image();
	facetex.image.onload = function() {
		++count;
		handleLoadedTexture(facetex);
	}
	facetex.image.src = "img_face_a1.png";

	handtex = gl.createTexture();
	handtex.image = new Image();
	handtex.image.onload = function() {
		++count;
		handleLoadedTexture(handtex);
	}
	handtex.image.src = "img_hand_chef_overlay.png";

	handnormals = gl.createTexture();
	handnormals.image = new Image();
	handnormals.image.onload = function() {
		++count;
		handleLoadedTexture(handnormals);
	}
	handnormals.image.src = "img_hand_chefn.png";

	foottex = gl.createTexture();
	foottex.image = new Image();
	foottex.image.onload = function() {
		++count;
		handleLoadedTexture(foottex);
	}
	foottex.image.src = "img_foot_chef_overlay.png";

	footnormals = gl.createTexture();
	footnormals.image = new Image();
	footnormals.image.onload = function() {
		++count;
		handleLoadedTexture(footnormals);
	}
	footnormals.image.src = "img_foot_chefn.png";
}

function init() {
	try {
		requestAnimationFrame = window.requestAnimationFrame;
		if (requestAnimationFrame == null) requestAnimationFrame = window.mozRequestAnimationFrame;
		if (requestAnimationFrame == null) requestAnimationFrame = window.webkitRequestAnimationFrame;
		if (requestAnimationFrame == null) requestAnimationFrame = window.msRequestAnimationFrame;
		gl = document.getElementById("webgl").getContext("experimental-webgl");
		if (!gl) { throw "Your web browser does not support WebGL!"; }
		initTexture();
		shader1 = shaderProgram(gl, "vs", "fs");
		shader2 = shaderProgram(gl, "vs2", "fs2");
		draw();
	}
	catch (e) {
		alert("Error: " + e);
	}
}
setTimeout(init, 100);

</script>
<canvas id="webgl" width="640" height="480"></canvas>
</body>
</html>